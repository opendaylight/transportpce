{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "78891eba_e3157203",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 7217
      },
      "writtenOn": "2024-09-02T13:01:16Z",
      "side": 1,
      "message": "Thanks Joakim for this refacto.\nThis looks to me much less abstracted and easier to understand than previous version.\nI have two main comments : \n1) Classes naming :  Available, Numeric and Math are still very abstracted and does not really reflect what it does. In this change it is understandable, but at the end when we will call the methods in other Tapi classes, it does not give an idea of what it does. So continuing your approach, I would suggest finding some names in connection with what it does. As an example (it is a suggestion, not supposed to be the best naming!):\nAvailable --\u003e GridUsage, AvailableGrid --\u003e GridUsageImpl\nMath --\u003e FreqAndIndex, FrequencyMath --\u003e FreqAndIndexImpl\nNumeric --\u003e FreqRange, NumericFrequency --\u003e FreqRangeImpl\n2) I may have missed something, but I don\u0027t see the value of using signed bytes vs unsigned to described Bytes spectrum usage. Especially if we consider that there is potentially 3 options to code signed bytes, and that you are using 2 complements option : so to assimilate what you put in your comments we need to translate it. Why not simply using unsigned bytes? Have you planned to make specific operations that signed bytes would simplify ?\nThanks!",
      "revId": "72b342db03d62bae68ad92d88794256c8e113e73",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e639de53_557cacc3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 7217
      },
      "writtenOn": "2024-09-02T14:58:08Z",
      "side": 1,
      "message": "Sorry, forgot one comment",
      "revId": "72b342db03d62bae68ad92d88794256c8e113e73",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "159811d3_221aea3b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 7217
      },
      "writtenOn": "2024-09-02T16:11:41Z",
      "side": 1,
      "message": "About previous comments, after looking at the change that sits on top of this one, I think the renaming of some of the classes to reflect more what\u0027s in, may be done in a further step, just to avoid additional unnecessary work. Thanks!",
      "revId": "72b342db03d62bae68ad92d88794256c8e113e73",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "75e9fc19_41be7453",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 9231
      },
      "writtenOn": "2024-09-03T11:51:04Z",
      "side": 1,
      "message": "Thanks Olivier for taking the time to review!\n\n1)\n\"Available, Numeric and Math are still very abstracted and does not really reflect what it does.\"\n\nWell, they are interfaces and as such they are not supposed to \"do anything\" apart from specifying a \"contract\" to be implemented by a class. Meaning, specifying methods that do something. I also intentionally avoid naming classes based on what they do (I leave that to the methods). Instead I try to name them according to what they are or represent or model. Oftentimes I omit information in class names that can be found in the package name (in this case tapi/frequency). Otherwise you can end up with every class in a package having the same prefix/suffix making them more or less redundant.\n\nAfter all, java.lang.Math is very different from transportpce.tapi.frequency.Math.\n\nWith that said though, perhaps the current interface names are a bit too vague.\n\n    Available --\u003e GridUsage, AvailableGrid --\u003e GridUsageImpl\n\nFair point, Available is probably too vague. Both GridUsage or Grid would work, although the word \"Usage\" rubs me the wrong way. However, both names could be implemented by classes like AvailableGrid and UsedGrid. But the class name GridUsageImpl is just as vague as the interface it\u0027s implementing. Does it represent the available or used grid? It\u0027s an important distinction and I feel the class name should reflect it. The suffix \"Impl\" doesn\u0027t really add anything useful and all in all the name GridUsageImpl is far more ambiguous than the class AvailableGrid, imho. \n\n    Math --\u003e FreqAndIndex, FrequencyMath --\u003e FreqAndIndexImpl\n\nThe name FreqAndIndex is too specific and are trying to communicate the methods (or behaviour) within it. Having a tight coupling between the interface name and the methods usually makes it awkward to update the interface later on. Should we rename the interface simply because we added or removed a method? As an example, if we add a method such as owner() to a Vehicle interface, isn\u0027t it still a Vehicle? Do the interface name really need to communicate that the interface specifies a method by which one may get the vehicle owner information?\n\n    Numeric --\u003e FreqRange, NumericFrequency --\u003e FreqRangeImpl\n\nI agree the interface name Numeric in this case can be improved. However, I\u0027m not a fan of abbreviations. Secondly, I find the name FreqRange too specific for the interface and is perhaps more suitable for the implementing class. I\u0027m leaning towards the interface \"Range\" or \"Interval\" and the implementing class \"FrequencyRange\" or FrequencyInterval.\n\n2)\n\"I may have missed something, but I don\u0027t see the value of using signed bytes vs unsigned to described Bytes spectrum usage.\"\n\nThe byte data type is an 8-bit signed two\u0027s complement integer. It has a minimum value of -128 and a maximum value of 127 (inclusive):\nhttps://docs.oracle.com/javase%2Ftutorial%2F/java/nutsandbolts/datatypes.html\n\nWith that said, I\u0027m simply working with what I have at my disposal. Consider the method getTTPUsedFreqMap(TerminationPoint tp) in the class ConvertORToTapiTopology:\n\n    public Map\u003cDouble, Double\u003e getTTPUsedFreqMap(TerminationPoint tp) {\n\n        ...\n        byte[] freqBitSet \u003d new byte[GridConstant.NB_OCTECTS];\n        ...\n        freqBitSet \u003d txttpAttAvlFreqMaps.entrySet().stream()\n                        .filter(afm -\u003e afm.getKey().equals(availFreqMapsKey))\n                        .findFirst().orElseThrow().getValue().getFreqMap();\n        ...\n\n    }\n\nfreqBitSet is an array containing signed bytes. As inconvenient as it may seem, it is what we have to work with. It\u0027s possible to get the unsigned counterpart by using something like Byte.toUnsignedInt(...), but in this case it\u0027s more of a pointless step sideways since we want to convert to a BitSet anyway.\n\n\"...and that you are using 2 complements option : so to assimilate what you put in your comments we need to translate it.\"\n\nI\u0027m sorry, but you lost me. Can you elaborate what you mean?",
      "parentUuid": "78891eba_e3157203",
      "revId": "72b342db03d62bae68ad92d88794256c8e113e73",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "96567650_456e40d3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 7217
      },
      "writtenOn": "2024-09-04T14:49:31Z",
      "side": 1,
      "message": "Hi Joakim. Thanks for your prompt answer! I globaly agree with your comments about interfaces, implementation \u0026 methods. Yes it shall not try to reflect what the methods do. \n\nHowever, having an idea of what it deals with is helpfull. Taking the example of Available, as the some of the methods in are related to availability, and some others to assignement (the opposite), \"Available\" is confusing to me.\n\nThe Impl extension is what we have been using until now, completing the interface name, to name the class where the implementation of the interface is done. This was the reason of suggesting this names. Don\u0027t know if this is a common usage, or just a naming convention that we agreed on. But at least, it respects what\u0027s already there.\nMath is confusing to me because it already exist in a completely different context. What it suggests to me is an interface that defines the signature of mathematic methods that apply to a specific type. FreqAndIndex reflect the fact that we provide a set of methods handling relationship between the two items. Not exactely what they do.\nFor numeric vs FreqRange, yes this last reflects what the implementation does, but if we apply the convention we have been using until now with Impl, I don\u0027t see this as an issue.\n\nHowever, whatever we decide, this can be done in a second step, to avoid reworking other changes on top of it.\n\nAbout the bytes, Sorry I did not realized that this comes from the type we have been using and that it was defining signed 2\u0027s complement integer. I though it was generic and could be use for both signed or unsigned int. My mistake, forget it! When I say we need to translate it, I meant that my mind is not so agile  to decode live from the binary writing what is the corresponding decimal value and inversely!",
      "parentUuid": "75e9fc19_41be7453",
      "revId": "72b342db03d62bae68ad92d88794256c8e113e73",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a58cec6c_cabfaccc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 9231
      },
      "writtenOn": "2024-09-05T10:50:52Z",
      "side": 1,
      "message": "\"Impl extension is what we have been using until now, completing the interface name, to name the class where the implementation of the interface is done\"\n\nI understand. My concern is the suggested naming convention implies and requires a one to one relationship between the interface and the implementing class to work. However, there are no such technical restrictions in java. Java supports a one to many relationship. This opens up the possibility for polymorphism. By enforcing the naming convention, you\u0027re needlessly limiting your options and closing the door on a very useful and powerful feature in OOP. Therefore, this kind of self imposed restrictions serves no useful purpose, whether intentional or not, imho.\n\n\"Math is confusing to me because it already exist in a completely different context. What it suggests to me is an interface that defines the signature of mathematic methods that apply to a specific type.\"\n\nExactly, different contexts. I\u0027m not saying Math was the better option. I\u0027m saying I think you have to view interfaces/and classes relative to the package/module they belong to, as opposed to a global context. The argument \"Math\" is used elsewhere is irrelevant, imho. A problem like that could easily be created by including a new module or resolved by removing a module.\n\nOftentimes most of the classes are only useful within a package, even though they may not be forbidden or restricted to be used elsewhere. Sometimes only a few classes are of potential use elsewhere. Trying to name classes so they fit into multiple contexts at once is usually not practical or useful. Sometimes it might even be counterproductive. \n\nAs an example, a registered User in the \"account\" package could be Name, Address, Phone number and Email. But in the \"newsletter\" package, a User (email recipient or sender) could be Name and Email only. Simply because the e-mail server has no use for a physical address or phone number. Both of these two packages/modules could have separate interfaces called \"User\". That\u0027s fine, and viewed within their respective packages, while ignoring the rest of the application, it might seem perfectly logical. By separating the two interfaces, they can be updated and used independently. In the end, different models fulfil different requirements, despite potentially having similar names. Taking those differences into account is more important than having globally unique names, imho.",
      "parentUuid": "96567650_456e40d3",
      "revId": "72b342db03d62bae68ad92d88794256c8e113e73",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac96ff27_ac06219f",
        "filename": "tapi/src/main/java/org/opendaylight/transportpce/tapi/frequency/NumericFrequency.java",
        "patchSetId": 18
      },
      "lineNbr": 51,
      "author": {
        "id": 7217
      },
      "writtenOn": "2024-09-02T13:01:16Z",
      "side": 1,
      "message": "Not so clear to me even if I understand the spirit. What about something more in line with the names of the methods provided in the interfaces, like : \n\n// Provides a Map \u003cLowerFreq, HigherFreq\u003e describing start and stop frequencies \n// of contiguous unitary slots set to 1/true in the BitSet : \n//   _ If the Bitset corresponds to available slots, the map provides boundaries of\n//     available spectrum portions\n//   _ If the Bitset corresponds to assigned slots, the map provides boundaries of \n//     occupied spectrum portions\n?",
      "range": {
        "startLine": 48,
        "startChar": 0,
        "endLine": 51,
        "endChar": 41
      },
      "revId": "72b342db03d62bae68ad92d88794256c8e113e73",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cb86fd98_b8f16b83",
        "filename": "tapi/src/main/java/org/opendaylight/transportpce/tapi/frequency/NumericFrequency.java",
        "patchSetId": 18
      },
      "lineNbr": 51,
      "author": {
        "id": 9231
      },
      "writtenOn": "2024-09-03T11:51:04Z",
      "side": 1,
      "message": "Good point. I have to confess I found this comment rather confusing. The method is a refactored version from an existing method in ConvertORToTapiTopology. I was lazy and kept this comment as is. I think we could get rid of it altogether.",
      "parentUuid": "ac96ff27_ac06219f",
      "range": {
        "startLine": 48,
        "startChar": 0,
        "endLine": 51,
        "endChar": 41
      },
      "revId": "72b342db03d62bae68ad92d88794256c8e113e73",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b6f7578d_5465d120",
        "filename": "tapi/src/main/java/org/opendaylight/transportpce/tapi/frequency/NumericFrequency.java",
        "patchSetId": 18
      },
      "lineNbr": 51,
      "author": {
        "id": 7217
      },
      "writtenOn": "2024-09-04T14:49:31Z",
      "side": 1,
      "message": "The first line of the comment contained an information about the fact that the key is the start freq and the value the stop. It could have been valuable to keep it...However, it can be easily deduced from the code itself. I agree on the fact that I am sometimes a bit verbose in my comments!",
      "parentUuid": "cb86fd98_b8f16b83",
      "range": {
        "startLine": 48,
        "startChar": 0,
        "endLine": 51,
        "endChar": 41
      },
      "revId": "72b342db03d62bae68ad92d88794256c8e113e73",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a2c3b60_0654004a",
        "filename": "tapi/src/test/java/org/opendaylight/transportpce/tapi/frequency/AvailableGridTest.java",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 7217
      },
      "writtenOn": "2024-09-02T14:58:08Z",
      "side": 1,
      "message": "Looks confusing to me. Why do you name \"available\" a variable that corresponds to what is assigned and vice-versa ?",
      "range": {
        "startLine": 153,
        "startChar": 0,
        "endLine": 157,
        "endChar": 67
      },
      "revId": "72b342db03d62bae68ad92d88794256c8e113e73",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7281c53e_0b9a2536",
        "filename": "tapi/src/test/java/org/opendaylight/transportpce/tapi/frequency/AvailableGridTest.java",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 9231
      },
      "writtenOn": "2024-09-03T11:51:04Z",
      "side": 1,
      "message": "Thanks, you\u0027re right, it is confusing. My mistake. I think this is a case of refactoring gone wrong.",
      "parentUuid": "4a2c3b60_0654004a",
      "range": {
        "startLine": 153,
        "startChar": 0,
        "endLine": 157,
        "endChar": 67
      },
      "revId": "72b342db03d62bae68ad92d88794256c8e113e73",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    }
  ]
}