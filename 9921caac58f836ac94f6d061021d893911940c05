{
  "comments": [
    {
      "key": {
        "uuid": "6843255a_90f09c83",
        "filename": "renderer/src/main/java/org/opendaylight/transportpce/renderer/openroadminterface/OpenRoadmInterface221.java",
        "patchSetId": 11
      },
      "lineNbr": 358,
      "author": {
        "id": 7217
      },
      "writtenOn": "2020-04-09T14:25:18Z",
      "side": 1,
      "message": "1) SAPI and DAPI are coded on 16 bytes (multiframe). This means if we assume that one letter is coded over one Bytes that we will be limited to 16 lettres. We need to find a way to limit the length of the sting made by anodeId + a logicalConnectionPoint because there is ahigh probability that it will not feet. As an example we could translate XPDR to X, Client to C, Network to N.....\n2) Could we add to this a setExpectedSapi and setExpectedDapi (What\u0027s the node is expecing to receive from remote node as SAPI/DAPI --\u003e same elements crossed ExpectedSAPI \u003d DAPI, Expected DAPI \u003d SAPI)",
      "revId": "9921caac58f836ac94f6d061021d893911940c05",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cde37c1e_1e26db9b",
        "filename": "renderer/src/main/java/org/opendaylight/transportpce/renderer/openroadminterface/OpenRoadmInterface221.java",
        "patchSetId": 11
      },
      "lineNbr": 358,
      "author": {
        "id": 6731
      },
      "writtenOn": "2020-04-20T14:19:00Z",
      "side": 1,
      "message": "some pointers for 128 bytes \"reversible\" hash functions and their perf\n\nhttps://en.wikipedia.org/wiki/List_of_hash_functions#Non-cryptographic_hash_functions\n\nhttps://greenrobot.org/essentials/features/performant-hash-functions-for-java/comparison-of-hash-functions/",
      "parentUuid": "6843255a_90f09c83",
      "revId": "9921caac58f836ac94f6d061021d893911940c05",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b68370a9_fa50597e",
        "filename": "renderer/src/main/java/org/opendaylight/transportpce/renderer/openroadminterface/OpenRoadmInterface221.java",
        "patchSetId": 11
      },
      "lineNbr": 358,
      "author": {
        "id": 6731
      },
      "writtenOn": "2020-04-23T12:44:44Z",
      "side": 1,
      "message": "https://github.com/pmdamora/fnv-cracker-app/blob/master/src/main/java/passwordcrack/cracking/HashChecker.java",
      "parentUuid": "cde37c1e_1e26db9b",
      "revId": "9921caac58f836ac94f6d061021d893911940c05",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c7cac23_edb2e408",
        "filename": "renderer/src/main/java/org/opendaylight/transportpce/renderer/openroadminterface/OpenRoadmInterface221.java",
        "patchSetId": 11
      },
      "lineNbr": 358,
      "author": {
        "id": 6731
      },
      "writtenOn": "2020-04-23T13:47:48Z",
      "side": 1,
      "message": "FNV1 seems to be the algo with less collissions (only one on the English dictionary)\nIt is public domain and the preivous link point to a 128-bit implementation with a MIT license compatible with EPL.",
      "parentUuid": "b68370a9_fa50597e",
      "revId": "9921caac58f836ac94f6d061021d893911940c05",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cb7f005a_03ee3042",
        "filename": "renderer/src/main/java/org/opendaylight/transportpce/renderer/openroadminterface/OpenRoadmInterface221.java",
        "patchSetId": 11
      },
      "lineNbr": 358,
      "author": {
        "id": 6731
      },
      "writtenOn": "2020-04-29T14:07:50Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "1c7cac23_edb2e408",
      "revId": "9921caac58f836ac94f6d061021d893911940c05",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    }
  ]
}