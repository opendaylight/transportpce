{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6078e7d2_58e6084f",
        "filename": "tapi/src/main/java/org/opendaylight/transportpce/tapi/topology/ORtoTapiTopoConversionTools.java",
        "patchSetId": 1
      },
      "lineNbr": 1274,
      "author": {
        "id": 9231
      },
      "writtenOn": "2025-12-09T10:49:07Z",
      "side": 1,
      "message": "I think the refactoring into smaller helpers may have gone a bit too far. Right now. `hasTxTtpBand(...)` is called multiple times in the same path:\n\n* `getTTP11UsedFreqMap()`: calls `hasTxTtpBand(tp, cband)` \n* then calls `getTxTtpAvailableFreqMaps(tp, cband)` which calls `hasTxTtpBand(tp, cband)` again\n\nSeems redundant to call the same method twice. Sure, each method is unaware of what other methods are doing, which is a good thing. In this case though, it seems splitting the methods up has introduced redundancy, with little benefit.",
      "revId": "cf83a6b539844b07564a4573836f6fb1e580b652",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a22cb0c0_a2313d67",
        "filename": "tapi/src/main/java/org/opendaylight/transportpce/tapi/topology/ORtoTapiTopoConversionTools.java",
        "patchSetId": 1
      },
      "lineNbr": 1274,
      "author": {
        "id": 9387
      },
      "writtenOn": "2025-12-10T08:26:11Z",
      "side": 1,
      "message": "Hmm, I think you are right.\n\nI added the check for `has*Band()` into the `get*AvailableFreqMap()` because in that scope we need to be sure it has it, because we cannot rely on that it has already been checked.\n\nHowever with that check in place, we actually do not need to check it before we call `get*AvailableFreqMaps()` method, _IF_ we accept a possible empty maps repsonse.\n\nSo one solution could be to simply drop the `has*Band()` check higher up in the call chain and handle the map response instead?",
      "parentUuid": "6078e7d2_58e6084f",
      "revId": "cf83a6b539844b07564a4573836f6fb1e580b652",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa7ea43e_393cd926",
        "filename": "tapi/src/main/java/org/opendaylight/transportpce/tapi/topology/ORtoTapiTopoConversionTools.java",
        "patchSetId": 1
      },
      "lineNbr": 1274,
      "author": {
        "id": 9231
      },
      "writtenOn": "2025-12-10T11:10:27Z",
      "side": 1,
      "message": "I believe the overall problem stems from mixing two competing concerns:\n\n* “Does it exist?” (boolean check)\n* “Give me the object” (fetch)\n\nSince the existence check and the object retrieval are effectively the same decision point, splitting them into separate helpers doesn’t really pay off here, imho.\n\nIt might be simpler to just focus on retrieving something (or a safe default) and operate on that, rather than scattering existence checks across multiple methods.\n\ne.g. \n\n```\npublic Map\u003cFrequency, Frequency\u003e getPP11AvailableFrequencies(TerminationPoint1 tp) {\n\n    AvailFreqMapsKey cband \u003d new AvailFreqMapsKey(GridConstant.C_BAND);\n    Map\u003cAvailFreqMapsKey, AvailFreqMaps\u003e availFreqMaps \u003d getPpFrequencyMaps(tp);\n    Map\u003cDouble, Double\u003e availableRanges \u003d availableRanges(availFreqMaps, cband);\n\n    return new SortedRange(availableRanges).ranges();\n}\n\nprivate Map\u003cAvailFreqMapsKey, AvailFreqMaps\u003e getPpFrequencyMaps(TerminationPoint1 tp) {\n    if (tp \u003d\u003d null) {\n        return Map.of();\n    }\n\n    PpAttributes ppAtt \u003d tp.getPpAttributes();\n    if (ppAtt \u003d\u003d null) {\n        return Map.of();\n    }\n\n    if (ppAtt.getAvailFreqMaps() \u003d\u003d null) {\n        return Map.of();\n    }\n\n    return ppAtt.getAvailFreqMaps();\n}\n```\n\nSure, we\u0027re not returning early, but at the same time we\u0027re not scattering the responsibility of how to treat missing frequencies all over the place.",
      "parentUuid": "a22cb0c0_a2313d67",
      "revId": "cf83a6b539844b07564a4573836f6fb1e580b652",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9753b56_706ae713",
        "filename": "tapi/src/main/java/org/opendaylight/transportpce/tapi/topology/ORtoTapiTopoConversionTools.java",
        "patchSetId": 1
      },
      "lineNbr": 1274,
      "author": {
        "id": 9231
      },
      "writtenOn": "2025-12-10T21:01:22Z",
      "side": 1,
      "message": "I realize my previous comment was unclear, and I should’ve marked more than one line. I wrote the comment suggesting changes relative to the previous commit, and that wasn\u0027t very obvious or helpful. Sorry for the confusion—please bear with me as I try again. I\u0027ll attempt to be more specific.\n\nPrimarily, the previous commit in this relation chain left room for improvement. As an example, the method `getPP11UsedFrequencies()` had these lines that could use a refactor, imho:\n\n```\n    if (tp \u003d\u003d null) {\n        return new HashMap\u003c\u003e();\n    }\n\n    PpAttributes ppAtt \u003d tp.getPpAttributes();\n    if (ppAtt \u003d\u003d null) {\n        return Map.of();\n    }\n```\n\nA similar problem exists for TTP. As I understand it, this is also the problem you\u0027re trying to address with this change.\n\n# Remove\nAt a glance, solving the above issue, should warrant two new helper methods; one for PP and one for TTP. Adding eight new methods—six of which are just boolean checks—seems excessive, to say the least. However, it\u0027s possible I\u0027m completely missing the point here, please let me know.\n\nWhat I’m trying to say is that I think the eight methods below should be removed. In my opinion, they add complexity with little to no tangible benefit. I already felt hasBand() was a bit of a stretch, but these go too far for me. Also, despite all the null and presence checks, the refactor still relies on two methods returning null. Falling back to returning null seems like a questionable compromise, in my opinion—especially given the amount of effort that clearly went into this change.\n\nSo, for those reasons, I suggest removing these:\n\n```java\nprivate boolean hasPpBand(TerminationPoint1 tp, AvailFreqMapsKey bandKey) {}\nprivate boolean hasPpAttributes() {}\nprivate AvailFreqMaps getPpAvailableFreqMaps() {}\nprivate boolean hasTxTtpBand(...) {}\nprivate boolean hasTxTtpUsedWavelengths(...) {}\nprivate Map\u003cUsedWavelengthsKey, UsedWavelengths\u003e getTxTtpUsedWavelengths(...) {}\nprivate boolean hasTxTtpAttributes(...) {}\nprivate AvailFreqMaps getTxTtpAvailableFreqMaps(...) {}\n```\n\n# Replacement\n\nFrom my perspective, in a nutshell, this is an example of the original problem we\u0027re trying to solve:\n\n```\n    if (tp \u003d\u003d null) {\n        return new HashMap\u003c\u003e();\n    }\n\n    PpAttributes ppAtt \u003d tp.getPpAttributes();\n    if (ppAtt \u003d\u003d null) {\n        return Map.of();\n    }\n```\n\nGiven the original problem above, it could be solved by these two methods; one for PP and one for TTP (I\u0027ve omitted the TTP example above though). The two method\u0027s only responsibility is to \"extract\" available frequency maps from the \"domain model\". They either return an empty map or available frequency map. No null-values or additional checks required.\n\n```java\nprivate Map\u003cAvailFreqMapsKey, AvailFreqMaps\u003e getPpFrequencyMaps(\n        TerminationPoint1 tp) {\n    if (tp \u003d\u003d null) {\n        return Map.of();\n    }\n\n    PpAttributes ppAtt \u003d tp.getPpAttributes();\n    if (ppAtt \u003d\u003d null) {\n        return Map.of();\n    }\n\n    if (ppAtt.getAvailFreqMaps() \u003d\u003d null) {\n        return Map.of();\n    }\n\n    return ppAtt.getAvailFreqMaps();\n}\n\nprivate Map\u003cAvailFreqMapsKey, AvailFreqMaps\u003e getTtpFrequencyMaps(\n        TerminationPoint1 tp) {\n    if (tp \u003d\u003d null) {\n        return Map.of();\n    }\n\n    TxTtpAttributes txttpAtt \u003d tp.getTxTtpAttributes();\n    if (txttpAtt \u003d\u003d null) {\n        return Map.of();\n    }\n\n    if (txttpAtt.getAvailFreqMaps() \u003d\u003d null) {\n        return Map.of();\n    }\n\n    return txttpAtt.getAvailFreqMaps();\n}\n```\n\nThe two methods above also relies on `ranges()` being restored to something like  this (and hasBand() or a replacement...):\n\n```java\nprivate Map\u003cDouble, Double\u003e ranges(\n        Map\u003cAvailFreqMapsKey, AvailFreqMaps\u003e avlFreqMaps,\n        AvailFreqMapsKey bandKey,\n        Function\u003cAvailable, Map\u003cDouble, Double\u003e\u003e frequencyRange) {\n\n    if (!hasBand(avlFreqMaps, bandKey)) {\n        return Map.of();\n    }\n\n    AvailFreqMaps afm \u003d avlFreqMaps.get(bandKey);\n    byte[] freqByteSet \u003d Arrays.copyOf(afm.getFreqMap(), GridConstant.NB_OCTECTS);\n    return frequencyRange.apply(new AvailableGrid(freqByteSet));\n}\n```\n\n# Putting the pieces together\n\nThen, putting it all together, `getPP11AvailableFrequencies()` would look something like this:\n\n```java\npublic Map\u003cFrequency, Frequency\u003e getPP11AvailableFrequencies(\n        TerminationPoint1 tp) {\n\n    AvailFreqMapsKey cband \u003d new AvailFreqMapsKey(GridConstant.C_BAND);\n    Map\u003cAvailFreqMapsKey, AvailFreqMaps\u003e availFreqMaps \u003d getPpFrequencyMaps(tp);\n    Map\u003cDouble, Double\u003e availableRanges \u003d availableRanges(availFreqMaps, cband);\n\n    return new SortedRange(availableRanges).ranges();\n}\n```\n\nIn summary, the above...\n* ... reduces the nr of helper methods from eight to two\n* ... removes methods first checking for a value and then at a second pass tries to extract the value\n* ... removes the need to create helper methods returning `null` by design\n* ... reduces the footprint significantly without losing clarity\n* ... the same pattern should apply for the other PP methods as well as TTP, although I haven\u0027t had the time to actually verify. I\u0027ll omit those changes for now, this comment is long as it is.",
      "parentUuid": "aa7ea43e_393cd926",
      "revId": "cf83a6b539844b07564a4573836f6fb1e580b652",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5109b8e_561fb2e0",
        "filename": "tapi/src/main/java/org/opendaylight/transportpce/tapi/topology/ORtoTapiTopoConversionTools.java",
        "patchSetId": 1
      },
      "lineNbr": 1330,
      "author": {
        "id": 9231
      },
      "writtenOn": "2025-12-09T10:49:07Z",
      "side": 1,
      "message": "There are multiple NPE traps lurking in this one:\n\n    return new AvailFreqMapsBuilder().build();\n\nFirst of all, running the above line will throw a NPE:\n\n`java.lang.NullPointerException: Key component \"mapName\" may not be null`.\n\nSecondly, the built object will probably have `.getFreqMap()` \u003d\u003d null, so `Arrays.copyOf(null, ...)` will throw NPE.\n\nIf this project compiles with this change, the tests most likely never take this scenario into account. So the unit tests would need to be updated.\n\nPutting these NPE problems aside, this method is doing almost the same thing as `getTxTtpAvailableFreqMaps(...)`. Overall, I don\u0027t see the need for having two long \"parallel tracks\".\n\nWouldn\u0027t all of these `has`-checks become obsolete if `ranges` instead could deal with a `null` value?\n\ne.g.\n\n```\nprivate Map\u003cDouble, Double\u003e ranges(\n        @Nullable AvailFreqMaps afm,\n        Function\u003cAvailable, Map\u003cDouble, Double\u003e\u003e frequencyRange) {\n    if (afm \u003d\u003d null\n            || afm.getFreqMap() \u003d\u003d null\n            || afm.getFreqMap().length \u003d\u003d 0) {\n        return Map.of();\n    }\n    byte[] freqByteSet \u003d Arrays.copyOf(\n            afm.getFreqMap(),\n            GridConstant.NB_OCTECTS);\n    return frequencyRange.apply(new AvailableGrid(freqByteSet));\n}\n```\n\nIn this case there is less need for \"two parallel tracks\".",
      "revId": "cf83a6b539844b07564a4573836f6fb1e580b652",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52ee93e2_1bd767c3",
        "filename": "tapi/src/main/java/org/opendaylight/transportpce/tapi/topology/ORtoTapiTopoConversionTools.java",
        "patchSetId": 1
      },
      "lineNbr": 1330,
      "author": {
        "id": 9387
      },
      "writtenOn": "2025-12-10T08:26:11Z",
      "side": 1,
      "message": "Aight, putting gthe NPE\u0027s aside (I will update the tests),\nI dont see how we can get around fetching things from Pp in one use case, and fetching from TxTtp in another case. We need to do the exact same things but for two cases.\n\nWith that said, with the NPE traps above mentioned, yes, handling of a null value here seems easier than having to deal with an instantiation of an empty `availFreqMaps` which seems to be alot more work that just doing a builder.build()\n\nI can change them to return null instead.\n\nAre you ok with this fix?",
      "parentUuid": "a5109b8e_561fb2e0",
      "revId": "cf83a6b539844b07564a4573836f6fb1e580b652",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee3bbde5_9f6a599f",
        "filename": "tapi/src/main/java/org/opendaylight/transportpce/tapi/topology/ORtoTapiTopoConversionTools.java",
        "patchSetId": 1
      },
      "lineNbr": 1330,
      "author": {
        "id": 9231
      },
      "writtenOn": "2025-12-10T11:10:27Z",
      "side": 1,
      "message": "\u003e I dont see how we can get around fetching things from Pp in one use case, and fetching from TxTtp in another case.\n\nAgreed. That\u0027s why I chose to keep the methods as is regarding fetching e.g. `PpAttributes` and `Map\u003cAvailFreqMapsKey, AvailFreqMaps\u003e` and thus returning early.",
      "parentUuid": "52ee93e2_1bd767c3",
      "revId": "cf83a6b539844b07564a4573836f6fb1e580b652",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4aedb8dc_616890f8",
        "filename": "tapi/src/main/java/org/opendaylight/transportpce/tapi/topology/ORtoTapiTopoConversionTools.java",
        "patchSetId": 1
      },
      "lineNbr": 1351,
      "author": {
        "id": 9231
      },
      "writtenOn": "2025-12-09T10:49:07Z",
      "side": 1,
      "message": "I\u0027m not so sure about executing the same method over and over. In this case I\u0027d consider caching values so I don\u0027t have to call the same method again.\n\nAlso, I find caching values are slightly more readable. Using var in this example since I don\u0027t know the actual data type as I\u0027m writing this.\n\n```\nprivate boolean hasTxTtpBand(TerminationPoint1 tp, AvailFreqMapsKey bandKey) {\n    if (!hasTxTtpAttributes(tp)) {\n        return false;\n    }\n\n    var maps \u003d tp.getTxTtpAttributes().getAvailFreqMaps();\n    if (maps \u003d\u003d null) {\n        return false;\n    }\n\n    var band \u003d maps.get(bandKey);\n    if (band \u003d\u003d null) {\n        return false;\n    }\n\n    var freqMap \u003d band.getFreqMap();\n\n    return freqMap !\u003d null \u0026\u0026 freqMap.length \u003e 0;\n}\n```",
      "range": {
        "startLine": 1342,
        "startChar": 0,
        "endLine": 1351,
        "endChar": 5
      },
      "revId": "cf83a6b539844b07564a4573836f6fb1e580b652",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a6037d5b_e7466a00",
        "filename": "tapi/src/main/java/org/opendaylight/transportpce/tapi/topology/ORtoTapiTopoConversionTools.java",
        "patchSetId": 1
      },
      "lineNbr": 1351,
      "author": {
        "id": 9387
      },
      "writtenOn": "2025-12-10T08:26:11Z",
      "side": 1,
      "message": "Alright, this is just taste imho.\n\nWe can go either way, though I prefer my way. Its compact and I think very readable.\n\nBut I\u0027ll let you decide.",
      "parentUuid": "4aedb8dc_616890f8",
      "range": {
        "startLine": 1342,
        "startChar": 0,
        "endLine": 1351,
        "endChar": 5
      },
      "revId": "cf83a6b539844b07564a4573836f6fb1e580b652",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "67e3beda_de9bc421",
        "filename": "tapi/src/main/java/org/opendaylight/transportpce/tapi/topology/ORtoTapiTopoConversionTools.java",
        "patchSetId": 1
      },
      "lineNbr": 1351,
      "author": {
        "id": 9231
      },
      "writtenOn": "2025-12-10T11:10:27Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "a6037d5b_e7466a00",
      "range": {
        "startLine": 1342,
        "startChar": 0,
        "endLine": 1351,
        "endChar": 5
      },
      "revId": "cf83a6b539844b07564a4573836f6fb1e580b652",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    }
  ]
}