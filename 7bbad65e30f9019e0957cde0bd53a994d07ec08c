{
  "pushCert": "certificate version 0.1\npusher 5FBDF9B9314FAD71 1757312983 +0200\npushee ssh://git.opendaylight.org:29418/transportpce\nnonce 1757312983-74B86E9C72DAC16272824EC716370265C5CAAA37\n\n0000000000000000000000000000000000000000 784d079158c0d0e6658342a6ec30017c9714ecac refs/for/master\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEIKU9c2lqXpTzMWXlX735uTFPrXEFAmi+d9cACgkQX735uTFP\nrXFjcBAApNbktyluipbrfc/ja5Mad8InRDK/pwVIkUR5vSttKIr/GHMZZHwzILNP\ntVjTteAbTYxBLyLA+qfYASR5roLIPKQT7GF4EexkFgrLni/wdLA6tbz+sXdqn7Xi\nSt+hFk/H1Z+qJ4QnLz8UPGtTQWeKtpsYNYGmXqXrAmRZL5493tAbytzxHK4xABN4\nIhkaoCUQ6eCptgNItyTNwWTgxF50wwEkkghCqHxkmsT/Dog7ILF3+hJguivg+yvr\nXgH+bDYV/rQMQXW8wsukxiHshmE1R9FBOFDlrifgxZCrHS6FVVijn1l4+2RJFkrN\nCqOcqUTvKQC8+n0bzkAIULiGI0xlb8QX5gbSu98spfys4GTFoKwMtFb8wJmQiSgU\nx60XpShmqxSrOlUkl+8ke7lXDXWyIzxIKDPZfileyNYGiwbSBicLiLe+4jrjFvQO\n2K72Us9LZh1sxg5lc3VqOqts+/ZzkaBCAI8s+MqRN0MU8aGnMdBAexxxA/b0beW6\nsyopwQUZlL+7tthcrvz577cXpl2k/bW6RfN2rozi7zxuq/EZ7gqfdPScW2fJ1vHl\nL/o2CrOKDcDzF33zT08R/lxoqyyHGQ7QEhJ3Dv6fVqHaZ37wLH982XHl0XEQMbQm\nHq3tYcjKTI24xE/9txZTSCtPAoe2zAEA3HaPJEgIocxHOgzKWDY\u003d\n\u003dQ8tA\n-----END PGP SIGNATURE-----\n",
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "ae027d3b_be57ab59",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 32
      },
      "lineNbr": 0,
      "author": {
        "id": 7217
      },
      "writtenOn": "2025-09-30T14:33:37Z",
      "side": 1,
      "message": "Sorry Joakim, but as per now, I can not accept this change to be merged. It is in contradiction with what we try to build for the T-API PCE. I will make my last changes public (did not make itbecause they are still draft) so that you see what we try to do.\n\nMy first analysis was based on the following observation and assumptions: \n1)\tCurrently, we update tapi-context on a successful path computation. As mentioned earlier, this is not the right way of doing it, since service and topology shall be only updated after the service has been successfully rendered.\n2)\tMy assumption was that you would adjust the code so that service and topology are updated after the service is rendered. This is what you are currently implementing, but the change looks to uncomplete, (even considering changes on the top), and some the methods that you have deleted in TapiPceNotificationHandler have no equivalent in the right place (probably TapiServiceNotificationHandler).\n\nSo let me give you a few contextual elements, and try to clarify a few things (sorry again, it’s a bit long, but I prefer to write it down rather than just saying it during a call with no trace to rely on it later on).\n\nCurrently connectivity-service creation requests exercised through TAPI API are translated into OR service-create to be handled by the Service Handler (SH). \n\nAt tapi-feature activation an initial mapping shall lead to the copy of OR services into the TAPI datastore. However, as most of the time, tapi feature is activated at transportPce start, there is no service in the datastore when tapi feature is installed. This needs to be checked (I am currently debugging the PCE code, not everything is done, and I still have a lot of things to double check), but I think that when an OR service is created through OR API, it is not copied in the TAPI datastore (maybe a bug or a choice : don\u0027t know,I did not write this part of the code…). However, I like it, and would like to keep this behavior, so that we have in the TAPI service datastore, only what is created from the TAPI API. We can discuss this, especially if this not what your customers are asking… The idea is to avoid duplicating unnecessary data. OR Service database would contain what’s created from OR API, and reversely for TAPI.\n\nCurrently, Path computation is performed through OR PCE (WDM+OTN) whatever the request comes from (TAPI/OR).\n\nWith the new TAPI PCE code we are working on, if a create-connectivity-service request is exercised, and if the service name is identified as a Uuid (this is the criteria we currently use, but it could be changed later on), the TAPI PCE will be triggered. TAPI PCE runs over the TAPI topology for WDM, + the connectivity context  _which includes connections_  for OTN. Right now, as we don’t have any TAPI renderer, a TAPI path computation will not be followed by any rendering task (it will abort)\nIf a create-connectivity-service request is exercised with a service name that is not conform to uuid pattern (simple name), path-computation will still be handled by the OR PCE. \nThis allows us to test TAPI PCE on the one hand (using uuid), but also to create tapi connectivity services (using regular name, thus triggering OR PCE and following rendering tasks) on the other hand. The connectivity service will be updated as well as the resulting connections in T-API datastore (should probably say \"should\"rather than \"will\", since I still experience some issue at this stage). This last is a must : this step is required so that we can fully test the TAPI PCE: as an example, we first create a WDM service, then an ODU4 service over created connections, then an Ethernet service and its LO ODU connections over the ODU4 connections in the last step.\n\nSo, I don’t have any issue with updating TAPI connectivity service database from the result of the service rendering. This is what whall be done (rather than doing it on Path Computation result).\n\nI have an issue with updating  TAPI connectivity service database listening to any OR service successful creation : would prefer that only the one exercised from TAPI API shall be put in TAPI datastore. This is probably in contradiction with what we initially put in place but we try to adjust the code and make it better as we pursue or investigations and debug the “end to end” tapi implementation.\n\nI have also an issue with removing the code that you deleted in TapiPceNotificationHandler.\n\nIn TapiPceNotificationHandler : \n1) onPathComputationResult must be kept, because we need to build a path description after a path computation occurred in the TAPI-PCE.\n2) UpdateTopologywithNep and updateTopologyWithCEP : these functions or their equivalent shall be somewhere else (probably in TapiPceNotificationHandler). I guess you handle it now in a different way, catching ServiceRpcResultSH notifications in changes on top of this one. If this is the case, would you mind pointing me to where this is done? As from your replies to my comments in change 116657, it seems that you really focusing on spectral aspects, just would like to make sure this handled somewhere.Additionnaly, it does not only concerns ROADMS but also transponders.\n3) UpdateConnectionContextWithConn : this function was removed and is not called anymore. It needs to be restore as onPathComputationResult method is restored.\n4) In CreateConnectivityServiceImpl (ccsi), you cancel the call of tapiContext.updateConnectivityContext: did you check whether this is called elsewhere at the right time (after the service has been correctly rendered)? If this method is not called elsewhere, would you mind triggering this update in the right place according to your proposed implementation?  We need to update connections after a service has been correctly rendered as they will be used as the supporting connections (equivalent to supporting OTN links) for services to come on top of them.\n\nSorry to come up very lately with my comments, but it seems that we are working on both side changing the same code with concurrent requirements...",
      "revId": "7bbad65e30f9019e0957cde0bd53a994d07ec08c",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "19532608_b8ff8196",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 32
      },
      "lineNbr": 0,
      "author": {
        "id": 8358
      },
      "writtenOn": "2025-09-30T20:17:51Z",
      "side": 1,
      "message": "\u003eI think that when an OR service is created through OR API, it is not copied in the TAPI datastore\n\nYes, correct, that is what we wanted to fix.\n\n\u003eHowever, I like it, and would like to keep this behavior, so that we have in the TAPI service datastore, only what is created from the TAPI API.\n\nUnfortunately, this makes the TAPI feature useless for us in most cases as it is now.",
      "parentUuid": "ae027d3b_be57ab59",
      "revId": "7bbad65e30f9019e0957cde0bd53a994d07ec08c",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5eff56d4_3a1950e3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 32
      },
      "lineNbr": 0,
      "author": {
        "id": 7217
      },
      "writtenOn": "2025-10-16T09:12:59Z",
      "side": 1,
      "message": "Sorry for late feedback on latest developments in TAPI PCE and how we shall proceed with this change to avoid, as far as possible, future unsolvable merge conflicts.\n\nAfter a consolidation of TAPI-PCE code and having a number of functional tests running, would like to provide information on how it will work:\n\nIf a path-computation request is exercised using an Uuid for the service-name, a path computation is triggered through the TAPI PCE. This allows us to test the TAPI-PCE.\n\nWhen a create-connectivity-service is exercised using a string for the service-name, it is converted to an OR compliant service-create, and the path-computation is handled by the OR PCE. On successful path computation, the service is rendered using the regular process. The connectivity service is updated as well as the resulting connections in T-API datastore.\n\nI kept the initial implementation: in TapiPceNotificationHandler ,  onPathComputationResult builds a path description after a path computation occurred in the PCE. It also triggers through connectivityUtils the creation of connections and their update in the Datastore. At that stage, their states are DISABLED/LOCKED). Their state will be updated when a notification is received after the service has been correctly rendered. This is the way it works now, and at the end, I think it make sense.\n\nIn order to avoid potential merge conflicts when we will merge the code for the TAPI Pce, in TapiPceNotificationHandler I suggest that we keep in onServicePathRpcResult, the call of onPathComputationResult. onPathComputationResult needs to be kept as is, as well as updateConnectionContextWithConn. Both setInput and setServiceUuid shall be kept. However both updateTopologyWithCep and update TopologyWithNep can be removed, as you did.\n\nFor what concerns TAPI connectivity service database update, listening to ANY openRoadm service successful creation. I replied to Jonas comment. As a summary, I\u0027m fine with your approach, but to avoid potential scalability issues in the future, propose to make the update of TAPI connectivity services conditional to the value of a variable such as \"ServiceStoragePolicy\". If this variable has the value “ORANDTAPI”, all created services will be updated in TAPI connectivity services. If this variable has the value “TAPIONLY”, only services that were created through TAPI interface shall be updated. In a first step we could hardly set it to “ORANDTAPI”.\nThis will allow us, later on, by just adding the code to be able to modify the setting of the variable externally (by an option at the tapi-feature installation), to trigger 2 potential behaviors that fit the user expectation. This would also fit with what we currently plan to do for the OR topology that we convert in the Tapi DataStore (ABSTRACTED vs FULL).\n\nHappy to discuss all of this with you during our next standup meeting, to see if this looks acceptable to you. \nThanks!",
      "revId": "7bbad65e30f9019e0957cde0bd53a994d07ec08c",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e0706424_42c04986",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 32
      },
      "lineNbr": 0,
      "author": {
        "id": 7217
      },
      "writtenOn": "2025-10-16T09:12:59Z",
      "side": 1,
      "message": "\u003e \u003eI think that when an OR service is created through OR API, it is not copied in the TAPI datastore\n\u003e \n\u003e Yes, correct, that is what we wanted to fix.\n\u003e \n\u003e \u003eHowever, I like it, and would like to keep this behavior, so that we have in the TAPI service datastore, only what is created from the TAPI API.\n\u003e \n\u003e Unfortunately, this makes the TAPI feature useless for us in most cases as it is now.\n\nOK, Understand from the explanation you gave us on why TAPI feature would be useless for the specific use case you consider (Use OR API to create/delete service as far it is transparent to the user who uses a GUI; whereas the TAPI interface is used to read topology and services in the DataStore.\n\nHowever, IMHO, this does not help improving scalability. My proposal is to implement it the way you wish, and at a later step, make this behaviour optional, giving the ability to the user to set the general behaviour of TAPI feature at instalation of the feature : \n\n- OR-Topology  in tapi Datastore : ABSTRACTED versus FULL\n- Services in tapi Datastore : ORANDTAPI versus TAPIONLY view (ORANDTAPI : all created services, TAPIONLY : only services that were created through TAPI interface)\n\nMaybe we should already condition this behaviour to the value of a variable such as \"ServiceStoragePolicy\", that we currently set to \"ORANDTAPI\" so that at later on, we just need to add the code to be able to modify the setting of the variable externally This would fit with what we currently do for the topology.\nIs it acceptable to you?\n@gilles.thouenon@orange.com : are you OK with this proposal?",
      "parentUuid": "19532608_b8ff8196",
      "revId": "7bbad65e30f9019e0957cde0bd53a994d07ec08c",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    }
  ]
}