{
  "pushCert": "certificate version 0.1\npusher 5FBDF9B9314FAD71 1757312983 +0200\npushee ssh://git.opendaylight.org:29418/transportpce\nnonce 1757312983-74B86E9C72DAC16272824EC716370265C5CAAA37\n\n0000000000000000000000000000000000000000 784d079158c0d0e6658342a6ec30017c9714ecac refs/for/master\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEIKU9c2lqXpTzMWXlX735uTFPrXEFAmi+d9cACgkQX735uTFP\nrXFjcBAApNbktyluipbrfc/ja5Mad8InRDK/pwVIkUR5vSttKIr/GHMZZHwzILNP\ntVjTteAbTYxBLyLA+qfYASR5roLIPKQT7GF4EexkFgrLni/wdLA6tbz+sXdqn7Xi\nSt+hFk/H1Z+qJ4QnLz8UPGtTQWeKtpsYNYGmXqXrAmRZL5493tAbytzxHK4xABN4\nIhkaoCUQ6eCptgNItyTNwWTgxF50wwEkkghCqHxkmsT/Dog7ILF3+hJguivg+yvr\nXgH+bDYV/rQMQXW8wsukxiHshmE1R9FBOFDlrifgxZCrHS6FVVijn1l4+2RJFkrN\nCqOcqUTvKQC8+n0bzkAIULiGI0xlb8QX5gbSu98spfys4GTFoKwMtFb8wJmQiSgU\nx60XpShmqxSrOlUkl+8ke7lXDXWyIzxIKDPZfileyNYGiwbSBicLiLe+4jrjFvQO\n2K72Us9LZh1sxg5lc3VqOqts+/ZzkaBCAI8s+MqRN0MU8aGnMdBAexxxA/b0beW6\nsyopwQUZlL+7tthcrvz577cXpl2k/bW6RfN2rozi7zxuq/EZ7gqfdPScW2fJ1vHl\nL/o2CrOKDcDzF33zT08R/lxoqyyHGQ7QEhJ3Dv6fVqHaZ37wLH982XHl0XEQMbQm\nHq3tYcjKTI24xE/9txZTSCtPAoe2zAEA3HaPJEgIocxHOgzKWDY\u003d\n\u003dQ8tA\n-----END PGP SIGNATURE-----\n",
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "ae027d3b_be57ab59",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 32
      },
      "lineNbr": 0,
      "author": {
        "id": 7217
      },
      "writtenOn": "2025-09-30T14:33:37Z",
      "side": 1,
      "message": "Sorry Joakim, but as per now, I can not accept this change to be merged. It is in contradiction with what we try to build for the T-API PCE. I will make my last changes public (did not make itbecause they are still draft) so that you see what we try to do.\n\nMy first analysis was based on the following observation and assumptions: \n1)\tCurrently, we update tapi-context on a successful path computation. As mentioned earlier, this is not the right way of doing it, since service and topology shall be only updated after the service has been successfully rendered.\n2)\tMy assumption was that you would adjust the code so that service and topology are updated after the service is rendered. This is what you are currently implementing, but the change looks to uncomplete, (even considering changes on the top), and some the methods that you have deleted in TapiPceNotificationHandler have no equivalent in the right place (probably TapiServiceNotificationHandler).\n\nSo let me give you a few contextual elements, and try to clarify a few things (sorry again, it’s a bit long, but I prefer to write it down rather than just saying it during a call with no trace to rely on it later on).\n\nCurrently connectivity-service creation requests exercised through TAPI API are translated into OR service-create to be handled by the Service Handler (SH). \n\nAt tapi-feature activation an initial mapping shall lead to the copy of OR services into the TAPI datastore. However, as most of the time, tapi feature is activated at transportPce start, there is no service in the datastore when tapi feature is installed. This needs to be checked (I am currently debugging the PCE code, not everything is done, and I still have a lot of things to double check), but I think that when an OR service is created through OR API, it is not copied in the TAPI datastore (maybe a bug or a choice : don\u0027t know,I did not write this part of the code…). However, I like it, and would like to keep this behavior, so that we have in the TAPI service datastore, only what is created from the TAPI API. We can discuss this, especially if this not what your customers are asking… The idea is to avoid duplicating unnecessary data. OR Service database would contain what’s created from OR API, and reversely for TAPI.\n\nCurrently, Path computation is performed through OR PCE (WDM+OTN) whatever the request comes from (TAPI/OR).\n\nWith the new TAPI PCE code we are working on, if a create-connectivity-service request is exercised, and if the service name is identified as a Uuid (this is the criteria we currently use, but it could be changed later on), the TAPI PCE will be triggered. TAPI PCE runs over the TAPI topology for WDM, + the connectivity context  _which includes connections_  for OTN. Right now, as we don’t have any TAPI renderer, a TAPI path computation will not be followed by any rendering task (it will abort)\nIf a create-connectivity-service request is exercised with a service name that is not conform to uuid pattern (simple name), path-computation will still be handled by the OR PCE. \nThis allows us to test TAPI PCE on the one hand (using uuid), but also to create tapi connectivity services (using regular name, thus triggering OR PCE and following rendering tasks) on the other hand. The connectivity service will be updated as well as the resulting connections in T-API datastore (should probably say \"should\"rather than \"will\", since I still experience some issue at this stage). This last is a must : this step is required so that we can fully test the TAPI PCE: as an example, we first create a WDM service, then an ODU4 service over created connections, then an Ethernet service and its LO ODU connections over the ODU4 connections in the last step.\n\nSo, I don’t have any issue with updating TAPI connectivity service database from the result of the service rendering. This is what whall be done (rather than doing it on Path Computation result).\n\nI have an issue with updating  TAPI connectivity service database listening to any OR service successful creation : would prefer that only the one exercised from TAPI API shall be put in TAPI datastore. This is probably in contradiction with what we initially put in place but we try to adjust the code and make it better as we pursue or investigations and debug the “end to end” tapi implementation.\n\nI have also an issue with removing the code that you deleted in TapiPceNotificationHandler.\n\nIn TapiPceNotificationHandler : \n1) onPathComputationResult must be kept, because we need to build a path description after a path computation occurred in the TAPI-PCE.\n2) UpdateTopologywithNep and updateTopologyWithCEP : these functions or their equivalent shall be somewhere else (probably in TapiPceNotificationHandler). I guess you handle it now in a different way, catching ServiceRpcResultSH notifications in changes on top of this one. If this is the case, would you mind pointing me to where this is done? As from your replies to my comments in change 116657, it seems that you really focusing on spectral aspects, just would like to make sure this handled somewhere.Additionnaly, it does not only concerns ROADMS but also transponders.\n3) UpdateConnectionContextWithConn : this function was removed and is not called anymore. It needs to be restore as onPathComputationResult method is restored.\n4) In CreateConnectivityServiceImpl (ccsi), you cancel the call of tapiContext.updateConnectivityContext: did you check whether this is called elsewhere at the right time (after the service has been correctly rendered)? If this method is not called elsewhere, would you mind triggering this update in the right place according to your proposed implementation?  We need to update connections after a service has been correctly rendered as they will be used as the supporting connections (equivalent to supporting OTN links) for services to come on top of them.\n\nSorry to come up very lately with my comments, but it seems that we are working on both side changing the same code with concurrent requirements...",
      "revId": "7bbad65e30f9019e0957cde0bd53a994d07ec08c",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "19532608_b8ff8196",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 32
      },
      "lineNbr": 0,
      "author": {
        "id": 8358
      },
      "writtenOn": "2025-09-30T20:17:51Z",
      "side": 1,
      "message": "\u003eI think that when an OR service is created through OR API, it is not copied in the TAPI datastore\n\nYes, correct, that is what we wanted to fix.\n\n\u003eHowever, I like it, and would like to keep this behavior, so that we have in the TAPI service datastore, only what is created from the TAPI API.\n\nUnfortunately, this makes the TAPI feature useless for us in most cases as it is now.",
      "parentUuid": "ae027d3b_be57ab59",
      "revId": "7bbad65e30f9019e0957cde0bd53a994d07ec08c",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    }
  ]
}